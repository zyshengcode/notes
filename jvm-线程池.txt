jmm：内存模型：

JMM定义了Java 虚拟机(JVM)在计算机内存(RAM)中的工作方式。JVM是整个计算机虚拟模型，所以JMM是隶属于JVM的。

--------

一个本地变量如果是原始类型，那么它会被完全存储到栈区。 

一个本地变量也有可能是一个对象的引用，这种情况下，这个本地引用会被存储到栈中
，但是对象本身仍然存储在堆区。



对于一个对象的成员方法，这些方法中包含本地变量，仍需要存储在栈区，即使它们所属的对象在堆区。
 
对于一个对象的成员变量，不管它是原始类型还是包装类型
，都会被存储到堆区。




Static类型的变量以及类本身相关信息都会随着类本身存储在堆区。

堆中的对象可以被多线程共享。
如果一个线程获得一个对象的应用，它便可访问这个对象的成员变量。如果两个线程同时调用了同一个对象
的同一个方法，
那么这两个线程便可同时访问这个对象的成员变量，但是对于本地变量，每个线程都会拷贝一份到自己的线程栈中。

---------------------
、
硬件架构：

现代计算机一般都有2个以上CPU，而且每个CPU还有可能包含多个核心。因此，如果我们的应用是多线程的话，
这些线程可能会在各个CPU核心中并行运行。



在CPU内部有一组CPU寄存器，也就是CPU的储存器。CPU操作寄存器的速度要比操作计算机主存快的多
。在主存和CPU寄存器之间还存在一个CPU缓存，

CPU操作CPU缓存的速度快于主存但慢于CPU寄存器。某些CPU可能有多个缓存层（一级缓存和二级缓存）
。计算机的主存也称作RAM，所有的CPU都能够访问主存，

而且主存比上面提到的缓存和寄存器大很多。

当一个CPU需要访问主存时，会先读取一部分主存数据到CPU缓存，
进而在读取CPU缓存到寄存器。当CPU需要写数据到主存时，

同样会先flush寄存器到CPU缓存，然后再在某些节点把缓存数据flush到主存。


----

java synchronized代码块。synchronized代码块可以保证同一个时刻只能有一个线程进入代码竞争区，

synchronized代码块也能保证代码块中所有变量都将会从主存中读，当线程退出代码块时，

对所有变量的更新将会flush到主存，不管这些变量是不是volatile类型的。

--

数据依赖性：

如果两个操作访问同一个变量，其中一个为写操作，此时这两个操作之间存在数据依赖性。
编译器和处理器不会改变存在数据依赖性关系的两个操作的执行顺序，即不会重排序。

----------------

内存屏障（Memory Barrier ）：



上面讲到了，通过内存屏障可以禁止特定类型处理器的重排序，从而让程序按我们预想的流程去执行。

内存屏障，又称内存栅栏，是一个CPU指令，基本上它是一条这样的指令：


保证特定操作的执行顺序。

影响某些数据（或则是某条指令的执行结果）的内存可见性。




编译器和CPU能够重排序指令，保证最终相同的结果，尝试优化性能。插入一条Memory Barrier会告诉编译器和CPU：
不管什么指令都不能和这条Memory Barrier指令重排序。



Memory Barrier所做的另外一件事是强制刷出各种CPU cache，如一个Write-Barrier（写入屏障）
将刷出所有在Barrier之前写入 cache 的数据，

因此，任何CPU上的线程都能读取到这些数据的最新版本。

这和java有什么关系？
上面java内存模型中讲到的volatile是基于Memory Barrier实现的。



如果一个变量是volatile修饰的，JMM会在写入这个字段之后插进一个Write-Barrier指令，
并在读这个字段之前插入一个Read-Barrier指令。

这意味着，如果写入一个volatile变量，就可以保证：


一个线程写入变量a后，任何线程访问该变量都会拿到最新值。


在写入变量a之前的写入操作，其更新的数据对于其他线程也是可见的。
因为Memory Barrier会刷出cache中的所有先前的写入。

---------------------
happens-before

 ：

从jdk5开始，java使用新的JSR-133内存模型，基于happens-before的概念来阐述操作之间的内存可见性。


在JMM中，如果一个操作的执行结果需要对另一个操作可见，那么这两个操作之间必须要存在happens-before关系
，这个的两个操作既可以在同一个线程，

也可以在不同的两个线程中。

与程序员密切相关的happens-before规则如下：




	程序顺序规则：一个线程中的每个操作，happens-before于该线程中任意的后续操作。


	监视器锁规则：对一个锁的解锁操作，happens-before于随后对这个锁的加锁操作。

	
volatile域规则：对一个volatile域的写操作，happens-before于任意线程后续对这个volatile域的读。


	传递性规则：如果 A happens-before B，且 B happens-before C，那么A happens-before C。




注意：两个操作之间具有happens-before关系，
并不意味前一个操作必须要在后一个操作之前执行！仅仅要求前一个操作的执行结果，
对于后一个操作是可见的，且前一个操作按顺序排在后一个操作之前。

------------------------


CAS

CAS:Compare and Swap, 翻译成比较并交换。 

java.util.concurrent包中借助CAS实现了区别于synchronouse同步锁的一种乐观锁。

 

本文先从CAS的应用说起，再深入原理解析。

 

CAS应用

CAS有3个操作数，内存值V，旧的预期值A，要修改的新值B。
当且仅当预期值A和内存值V相同时，将内存值V修改为B，否则什么都不做。



----------
任务（Runnable Callable）    线程池


============GC====


堆内存分配
JVM初始分配的内存由-Xms指定，默认是物理内存的1/64；
JVM最大分配的内存由 -Xmx指定，默认是物理内存的1/4。
默认空余堆内存小于40%时，JVM就会增大堆直到-Xmx的最大限制；
空余堆内存大于70%时，JVM会减少堆 直到-Xms的最小限制。
因此服务器一般设置-Xms、-Xmx相等以避免在每次GC 后调整堆的大小。

Xms：设置java应用程序启动时的初始堆大小
－Xmx：设置java应用程序能获得的最大堆大小
－Xss：设置线程栈的大小


1.mysql数据库的引擎

ISAM、MYISAM和HEAP。另外两种类型INNODB和BERKLEY（BDB）

MyIASM是MySQL默认的引擎，但是它没有提供对数据库事务的支持，也不支持行级锁和外键

　Innodb引擎提供了对数据库ACID事务的支持，并且实现了SQL标准的四种隔离级别

索引（Index）是帮助MySQL高效获取数据的数据结构。
MyIASM和Innodb都使用了树这种数据结构做为索引

2.什么情况下会出现死锁
3.说一下GC

4.声明和定义   定义需要分配内存

5.事务的隔离级别

6.悲观锁和乐观锁的区别
	
悲观锁：
就是很悲观，每次去拿数据的时候都认为别人会修改，
所以每次在拿数据的时候都会上锁，这样别人想拿这个
数据就会block直到它拿到锁。传统的关系型数据库里边
就用到了很多这种锁机制，比如行锁，表锁等，读锁，写锁等，
都是在做操作之前先上锁。它指的是对数据被外界（
包括本系统当前的其他事务，以及来自外部系统的事务处理
）修改持保守态度，因此，在整个数据处理过程中，将数据处于锁定状态

乐观锁：
就是很乐观，每次去拿数据的时候都认为别人不会修改，
所以不会上锁，但是在更新的时候会判断一下在此期间
别人有没有去更新这个数据，可以使用版本号等机制。
乐观锁适用于多读的应用类型，这样可以提高吞吐量，适应于并发量大的操作

7.进程间进行通信的方式

（1）.共享内存：共享内存就是两个进程同时共享一块内存，
然后在这块内存上的数据可以共同修改和读取，达到通信的目的
（2）.无名管道
（3）命名管道
（4）消息队列
（5）套接字：套接字是网络编程的api，
通过套接字可以不同的机器间的进程进行通信，
常用于客户端进程和服务器进程的通信。
（6）信号



8.堆栈内存溢出怎么进行调优

内存溢出：系统已经不能再分配出你所需要的空间，
比如你需要100M的空间，系统只剩90M了，这就叫内存溢出

内存泄漏：强引用所指向的对象不会被回收，可能导致内存泄漏，
虚拟机宁愿抛出OOM也不会去回收他指向的对象
	意思就是你用资源的时候为他开辟了一段空间，
	当你用完时忘记释放资源了，这时内存还被占用着，一次没关系，
	但是内存泄漏次数多了就会导致内存溢出

内存溢出的原因及解决方法：

    修改JVM启动参数，直接增加内存。(-Xms，-Xmx参数一定不要忘记加。)
    检查错误日志，查看“OutOfMemory”错误前是否有其 它异常或错误。
    对代码进行走查和分析，找出可能发生内存溢出的位置。
    使用内存查看工具动态查看内存使用情况　

堆内存分配
JVM初始分配的内存由-Xms指定，默认是物理内存的1/64；
JVM最大分配的内存由 -Xmx指定，默认是物理内存的1/4。
默认空余堆内存小于40%时，JVM就会增大堆直到-Xmx的最大限制；
空余堆内存大于70%时，JVM会减少堆 直到-Xms的最小限制。
因此服务器一般设置-Xms、-Xmx相等以避免在每次GC 后调整堆的大小。

栈大小设置以及溢出发生的情况：


栈是线程私有的，每个方法执行会创建一个栈帧，来存储局部变量表等

栈溢出----方法执行时创建的栈帧超过了栈的深度（比如递归）

解决办法：－Xss 设置栈的大小，栈的大小直接决定函数调用的可达深度。

*/

public class Stack

{

    public static void main(String[] args)

    {

        new Stack().test();

    }

    public void test()

    {

        test();

    }

}







堆溢出---------------一直无限的创建保存在集合里面的对象

*/

public class Heap

{

    public static void main(String[] args)

    {

        ArrayList list=new ArrayList();

        while(true)

        {

            list.add(new Heap());

        }

    }

}







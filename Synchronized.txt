synchronized关键字最主要的三种使用方式：

    修饰实例方法: 作用于当前对象实例加锁，进入同步代码前要获得当前对象实例的锁
    修饰静态方法: :也就是给当前类加锁，会作用于类的所有对象实例，因为静态成员不属于任何一个实例对象，
    是类成员（ static 表明这是该类的一个静态资源，不管new了多少个对象，只有一份）。
    所以如果一个线程A调用一个实例对象的非静态 synchronized 方法，
    而线程B需要调用这个实例对象所属类的静态 synchronized 方法，是允许的，不会发生互斥现象，
    因为访问静态 synchronized 方法占用的锁是当前类的锁，而访问非静态 synchronized 方法占用的锁是当前实例对象锁。
    修饰代码块: 指定加锁对象，对给定对象加锁，进入同步代码库前要获得给定对象的锁。

总结： synchronized 关键字加到 static 静态方法和 synchronized(class)代码块上都是是给 Class 类上锁。	
synchronized 关键字加到实例方法上是给对象实例上锁。尽量不要使用 synchronized(String a) 因为JVM中，
字符串常量池具有缓存功能！




Synchronized：　

Synchronized是Java中解决并发问题的一种最常用的方法，也是最简单的一种方法。Synchronized的作用主要有三个：

（1）确保线程互斥的访问同步代码（2）保证共享变量的修改能够及时可见（3）有效解决重排序问题。

  从语法上讲，Synchronized总共有三种用法：

　　（1）修饰普通方法

　　（2）修饰静态方法

　　（3）修饰代码块

使用volatile关键字仅能实现对原始变量(如boolen、 short 、int 、long等)操作的原子性，

但需要特别注意， volatile不能保证复合操作的原子性，即使只是i++，

实际上也是由多个原子操作组成：read i; inc; write i，假如多个线程同时执行i++，

volatile只能保证他们操作的i是同一块内存，但依然可能出现写入脏数据的情况。

---------------------

volatile和synchronized的区别




volatile本质是在告诉jvm当前变量在寄存器（工作内存）中的值是不确定的，需要从主存中读取； 
 synchronized则是锁定当前变量，只有当前线程可以访问该变量，其他线程被阻塞住。


volatile仅能使用在变量级别；synchronized则可以使用在变量、方法、和类级别的


volatile仅能实现变量的修改可见性，不能保证原子性；
而synchronized则可以保证变量的修改可见性和原子性
volatile不会造成线程的阻塞；
synchronized可能会造成线程的阻塞。


volatile标记的变量不会被编译器优化；synchronized标记的变量可以被编译器优化

---------------------

内存屏障（memory barrier）是一个CPU指令。基本上，它是这样一条指令： 

a) 确保一些特定操作执行的顺序； 

b) 影响一些数据的可见性(可能是某些指令执行后的结果)。
编译器和CPU可以在保证输出结果一样的情况下对指令重排序，
使性能得到优化。插入一个内存屏障，相当于告诉CPU和编译器先于这个命令的必须先执行，
后于这个命令的必须后执行。内存屏障另一个作用是强制更新一次不同CPU的缓存。
例如，一个写屏障会把这个屏障前写入的数据刷新到缓存，
这样任何试图读取该数据的线程将得到最新值，而不用考虑到底是被哪个cpu核心或者哪颗CPU执行的。

---------------------
volatile为什么没有原子性?

明白了内存屏障（memory barrier）这个CPU指令，回到前面的JVM指令：
从Load到store到内存屏障，一共4步，其中最后一步jvm让这个最新的变量的值在所有线程可见，
也就是最后一步让所有的CPU内核都获得了最新的值，但中间的几步（从Load到Store）是不安全的
，中间如果其他的CPU修改了值将会丢失。

-----

单机即一个jvm中，只需要采用线程锁，即lock与synchronize
分布式情况下：多jvm，线程锁没用，需要采用进程锁，即分布式锁来锁定资源


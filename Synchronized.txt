Synchronized：　

Synchronized是Java中解决并发问题的一种最常用的方法，也是最简单的一种方法。Synchronized的作用主要有三个：

（1）确保线程互斥的访问同步代码（2）保证共享变量的修改能够及时可见（3）有效解决重排序问题。

  从语法上讲，Synchronized总共有三种用法：

　　（1）修饰普通方法

　　（2）修饰静态方法

　　（3）修饰代码块

使用volatile关键字仅能实现对原始变量(如boolen、 short 、int 、long等)操作的原子性，

但需要特别注意， volatile不能保证复合操作的原子性，即使只是i++，

实际上也是由多个原子操作组成：read i; inc; write i，假如多个线程同时执行i++，

volatile只能保证他们操作的i是同一块内存，但依然可能出现写入脏数据的情况。

---------------------

volatile和synchronized的区别




volatile本质是在告诉jvm当前变量在寄存器（工作内存）中的值是不确定的，需要从主存中读取； 
 synchronized则是锁定当前变量，只有当前线程可以访问该变量，其他线程被阻塞住。


volatile仅能使用在变量级别；synchronized则可以使用在变量、方法、和类级别的


volatile仅能实现变量的修改可见性，不能保证原子性；
而synchronized则可以保证变量的修改可见性和原子性
volatile不会造成线程的阻塞；
synchronized可能会造成线程的阻塞。


volatile标记的变量不会被编译器优化；synchronized标记的变量可以被编译器优化

---------------------

内存屏障（memory barrier）是一个CPU指令。基本上，它是这样一条指令： 

a) 确保一些特定操作执行的顺序； 

b) 影响一些数据的可见性(可能是某些指令执行后的结果)。
编译器和CPU可以在保证输出结果一样的情况下对指令重排序，
使性能得到优化。插入一个内存屏障，相当于告诉CPU和编译器先于这个命令的必须先执行，
后于这个命令的必须后执行。内存屏障另一个作用是强制更新一次不同CPU的缓存。
例如，一个写屏障会把这个屏障前写入的数据刷新到缓存，
这样任何试图读取该数据的线程将得到最新值，而不用考虑到底是被哪个cpu核心或者哪颗CPU执行的。

---------------------
volatile为什么没有原子性?

明白了内存屏障（memory barrier）这个CPU指令，回到前面的JVM指令：
从Load到store到内存屏障，一共4步，其中最后一步jvm让这个最新的变量的值在所有线程可见，
也就是最后一步让所有的CPU内核都获得了最新的值，但中间的几步（从Load到Store）是不安全的
，中间如果其他的CPU修改了值将会丢失。


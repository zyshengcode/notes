RPC（同步请求）

消息队列：（异步，解耦，缓冲）

生产者（异步请求）<------->队列(缓冲作用：存储大量的请求)<------>消费者


建立连接----建立队列----绑定连接----消费消息

生产者：--

通过连接工厂创建连接 connectionFactory

通过工厂创建连接   

----------------------

block---mainloop(对block进行set)--block.get



无符号字节？？？
数据帧----由主循环线程一段段读取数据
Frame.fromBodyFragment

向服务端通过outputstream写数据这个是同步的，拿不到服务端响应（rpc同步请求）

但是通过主循环线程，可以同过inputstream向服务端拿到响应（这里有个死循环，不断从服务端读数据）

=================================

消息中间件：1.实现异步2.实现解耦（串行任务的并行化）
3.实现流量的削峰（负载均衡）

消息--->交换机--->分发消息（queue消息队列）

交换机（与队列进行绑定）类型：

	1.直连交换机----->精准匹配（1对1）

	2.主题交换机（*代表一个单词，#代表一个或多个单词）-->相当于模糊匹配（1对多）

	3.广播类型交换机	


交换机与队列在定义绑定关系的时候，需要注入交换机和队列

通过@Qualifier（“bean的名字”）-->来进行绑定


========================RabbitMQ=======================
配置：

1.consume

	======================================  基本配置 ===============
 	<!--配置connection-factory，指定连接rabbit server参数 -->
	<rabbit:connection-factory id="connectionFactory"
		username="${message}" password="${message}" host="${messag}" port="${mess}" /> 

	<!-- 序列化 -->
	<bean id="jsonMessageConverter" class="org.springframework.amqp.support.converter.Jackson2JsonMessageConverter"></bean>
	<!--定义rabbit template用于数据的接收和发送 -->
	<rabbit:template id="amqpTemplate"  connection-factory="connectionFactory" 
	    exchange="exchangeQueue" message-converter="jsonMessageConverter"/>
		
	<!--通过指定下面的admin信息，当前producer中的exchange和queue会在rabbitmq服务器上自动生成 -->
	<rabbit:admin connection-factory="connectionFactory" />

	==========================================定义queue以及交换机器==========================	

	<!--定义queue -->
	<rabbit:queue name="FOR_JDSW_MEMBER_REGISTERINFO" durable="true" auto-delete="false" exclusive="false" />

	<rabbit:queue name="FOR_JDSW_CREATE_CARDINFO" durable="true" auto-delete="false" exclusive="false" />

	<!-- 定义direct exchange，绑定queueTest -->
	<rabbit:direct-exchange name="exchangeQueue" durable="true" auto-delete="false">
		<rabbit:bindings>
			<rabbit:binding queue="FOR_JDSW_MEMBER_REGISTERINFO" key="FOR_JDSW_MEMBER_REGISTERINFO_KEY"></rabbit:binding>
			<rabbit:binding queue="FOR_JDSW_CREATE_CARDINFO" key="FOR_JDSW_CREATE_CARDINFO_KEY"></rabbit:binding>
		</rabbit:bindings>
	</rabbit:direct-exchange>

	=================================================定义消费类，对消息进行消费===================================	

	<!-- 监听积分发送的订单队列 -->
	<bean id="jdswCreateCardinfo" class="com.controller.ConsumeForMemberRegisteredInfo"/>
	<rabbit:listener-container connection-factory="connectionFactory" message-converter="jsonMessageConverter" acknowledge="manual">
		<rabbit:listener queues="FOR_JDSW_MEMBER_REGISTERINFO" ref="jdswCreateCardinfo"/>
	</rabbit:listener-container>


	<bean id="jdswRegisteredinfo" class="com.controller.ConsumeForCreateCardInfo"/>
	<rabbit:listener-container connection-factory="connectionFactory" message-converter="jsonMessageConverter" acknowledge="manual">
		<rabbit:listener queues="FOR_JDSW_CREATE_CARDINFO" ref="jdswRegisteredinfo"/>
	</rabbit:listener-container>

	消费类：	
	 1.ConsumeForMemberRegisteredInfo implements ChannelAwareMessageListener 	  实现接口
	 
	2.重写onMessage(Message message, Channel channel)                    方法

	 3. try {
            logger.info("接受MQ队列为：FOR_JDSW_MEMBER_REGISTERINFO");
            String synJsonStr = (String) convert.fromMessage(message);
            MemberCreateCardDTO memberCreateCardDTO = JSONObject.parseObject(synJsonStr, MemberCreateCardDTO.class);
            logger.info("接受MQ数据为：" + memberCreateCardDTO);
    
            memberInfoCallDjswController.memberRegisteredInfo(memberRegisteredInfoToDjswDTO);              -------------调用方法
        } catch (Exception e) {
            logger.info("exception {}"+e);
        } finally {
            channel.basicAck(message.getMessageProperties().getDeliveryTag(), false);          -----必须写
        }


2.product

	================= 定义基本信息  ========

		<!--配置connection-factory，指定连接rabbit server参数 -->
	<rabbit:connection-factory id="connectionFactory"
		username="${message.rmq.username}" password="${message.rmq.password}" host="${message.rmq.host}" port="${message.rmq.port}" /> 

	<!-- 序列化 -->
	<bean id="jsonMessageConverter"  class="org.springframework.amqp.support.converter.Jackson2JsonMessageConverter"></bean>
	<!--定义rabbit template用于数据的接收和发送 -->
	<rabbit:template id="amqpTemplate"  connection-factory="connectionFactory" 
	    exchange="exchangeQueue" message-converter="jsonMessageConverter"/>
		
	<!--通过指定下面的admin信息，当前producer中的exchange和queue会在rabbitmq服务器上自动生成 -->
	<rabbit:admin connection-factory="connectionFactory" />

		=============   配置q等消息   ==================
	
	<!--定义queue -->
	<rabbit:queue name="queueForPoints" durable="true" auto-delete="false" exclusive="false" />
	
	

	<!-- 定义direct exchange，绑定queueTest -->
	<rabbit:direct-exchange name="exchangeQueue" durable="true" auto-delete="false">
		<rabbit:bindings>
			<rabbit:binding queue="queueForPoints" key="queueForPtsKey"></rabbit:binding>
		</rabbit:bindings>
	</rabbit:direct-exchange>

		============消息产生类

	private AmqpTemplate amqpTemplate;

	public void sendMessage(String key, Object message) {                ===========key为queueForPtsKey
		logger.info("to send message:{}", message);
		// 发送对象，默认序列化。如果序列化，必须convertAnd发送
		try{
			amqpTemplate.convertAndSend(key, message);
		}catch(Exception e){
			logger.error("MessageProducer 消息产生,提交到队列中去:{}"+e.getMessage());
		}
		
	}





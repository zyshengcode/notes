PRC利用Socket API实现基于TCP协议的RPC调用，比如service中，或则controller中直接调用别人的方法




ZK：每个节点都可以存放数据，文件系统中只有文件节点可以存放数据而目录节点不行


Google Dapper

CAT：基于java开发的应用监控平台

访问增加--->吞吐量需要增加

负载均衡-->网关-->吧不通的任务给集群中不同的服务器---

-->集群--（一个任务由拆分成多个小任务---

--->（每个小节点由可以做集群），一起完成）--

- >转为分布式

分布式：一个功能分配为多个模块，分发到多台电脑（服务器上面）
集群：一个小模块功能，分别复制到多台机器上面，其中一台挂掉不影响功能。

负载均衡服务器（F5--硬负载  nginx---软负载）---吧请求路由到不同的节点


分布式：吧一个机器（即服务器）的这个任务--->分给多台不同的机器去完成这个任务

PRC（远程方式）--->dubbo，webservice，hession（协议）--->cxf（可用来开发webservice，通过协议发布接口）

远程调用方式--需要什么协议---协议可以通过什么框架来发布

网关：可做认证等事情

zookeeper：（分布式协调服务） dubbo服务A，dubbo服务B，dubboC，--

----存在竞争（用zookeeper来保证有序性）--->访问共享资源


========================微服务，分布式，springcloud，====================================================

RMI是RPC的一种实现

多协议支持---zookeeper---->记录服务的ip，端口，以及服务的协议（相当于服务的清单）


负载均衡策越：hash策略，轮训策越，随机策越

策越计算方式： 1.客户端策略 Ribbon
	       2.服务端记录所有节点信息，负责计算：反向代理---> nginx




===

===========zookeeper===类似文件目录结构的数据结构

三个节点访问同一个共享资源（利用zookeeper来协调）

节点访问---->zookeeper---->访问共享资源

有序节点（） 持久化节点（在磁盘）  临时节点（与session绑定）

zookeeper做集群：可以保证其可靠性，万一其中一个挂掉，其他注册节点可以起作用

事物请求：增加，删除，修改
非事物请求：查询

中心节点来处理事物请求：1.利于数据同步的问题，将处理完的数据同步到其他节点

zab协议：1.数据的同步 2.leader的选举

节点抢占   同级目录是唯一的   临时节点下面不能有子节点

watcher--->客户端监控某一个节点的变化---节点变化会通知客户端---
--->客服端会收到节点的信息与状态

获取监听有三种方式：get ，exists， getchildren

get /mic（节点名） true  开启节点监控  修改节点以后，会收到通知（只触发一次）


zookeeper应用：分布式锁（节点抢占）

RPC---协议规范----框架webservice，dubbo----实现cxf等

服务注册


====dubbo===

负载均衡与集群配对存在，负载利用算法来对请求进行分发


=================分布式事务=============

1.什么是事务，数据产生变化都会涉及到事务

原子-->不可以分割单元，一致，持久，隔离



分库（数据库）---->带来了数据的一致性问题

C：一致性   A：可用性（节点是可用的）  p:分区容错（）

保证CP(银行)/AP( 电商)

基于XA协议接口实现数据库的回滚或则提交（双向的）（XA是规范）

JTA：java提供的分布式事务接口规范



===========搜索引擎Elasticsearch==============







========================dubbo=============

SOAP是一种协议规范，基于xml的

RPC是一种远程调用协议（用户模块调用订单模块）

dubbo是实现rpc协议的一个框架

Web Service = SOAP + HTTP + WSDL


=============dubbo==========


RPC和MQ区别：RPC远程调用，MQ异步通信

1.invoke（远程通信）：socket网络编程，http协议，netty

dubbo/spring cloud源码  用高性能的netty（应用层）进行网络通信

2.register   通过curator将服务写到zk上面--->zk上面形成节点
用父节点key存储服务名称，用子节点key存储url地址（因为一个服务对应多个实现类）


provider：1.用netty方式启动一个端口监听  

	   2.接口有不同的实现类

	/com.ibm.cn.ZhanInter
	  /com.ibm.cn.ZhanInter/127.0.0.1:8081
	  /com.ibm.cn.ZhanInter/127.0.0.1:8082


	provider：一定是   Inter inter = new Inter（）；

	Consumer： Inter inter = 远程调用（netty发起一个远程调用请求）
			使用动态代理--->实现远程调用--->让consumer无感知


RPC核心：传输过程

	序列化与反序列化（socket是二进制的载体）


================
===
RPC（同步请求）

消息队列：（异步，解耦，缓冲）

生产者（异步请求）<------->队列(缓冲作用：存储大量的请求)<------>消费者


建立连接----建立队列----绑定连接----消费消息

生产者：--

通过连接工厂创建连接 connectionFactory

通过工厂创建连接   

----------------------

block---mainloop(对block进行set)--block.get



无符号字节？？？
数据帧----由主循环线程一段段读取数据
Frame.fromBodyFragment

向服务端通过outputstream写数据这个是同步的，拿不到服务端响应（rpc同步请求）

但是通过主循环线程，可以同过inputstream向服务端拿到响应（这里有个死循环，不断从服务端读数据）

=================================

消息中间件：1.实现异步2.实现解耦（串行任务的并行化）
3.实现流量的削峰（负载均衡）

消息--->交换机--->分发消息（queue消息队列）

交换机（与队列进行绑定）类型：

	1.直连交换机----->精准匹配（1对1）

	2.主题交换机（*代表一个单词，#代表一个或多个单词）-->相当于模糊匹配（1对多）

	3.广播类型交换机	


交换机与队列在定义绑定关系的时候，需要注入交换机和队列

通过@Qualifier（“bean的名字”）-->来进行绑定
